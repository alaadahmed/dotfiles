#+TITLE: Emacs Configuration File
#+AUTHOR: AlaaDAhmed

#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
#+HTML_HEAD: <style>pre.src{background:#fbf8ef;color:#3e3e3e;font-size:14px;}</style>

#+OPTION: num:nil
#+PROPERTY: header-args :results silent

* Setup
  
  Let's make first our startup faster

  #+BEGIN_SRC emacs-lisp
    (defvar file-name-handler-alist-old file-name-handler-alist)
    (setq package-enable-at-startup nil
	  file-name-handler-alist nil
	  message-log-max 16384
	  gc-cons-threshold 402653184
	  gc-cons-percentage 0.6
	  auto-window-vscroll nil
	  package--init-file-ensured t)

    (add-hook 'after-init-hook
	      `(lambda ()
		 (setq file-name-handler-alist file-name-handler-alist-old
		       gc-cons-threshold 800000
		       gc-cons-percentage 0.1)) t)
  #+END_SRC
  
  Then we are going to install package manger, I will go with straight
  so we have to bootstrap it.

** Setup Package Manger
   #+begin_src emacs-lisp
     (setq straight-use-package-by-default t)
     ;;;; Package Manager (Straight)
     (defvar bootstrap-version)
     (let ((bootstrap-file
	    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	   (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
	 (with-current-buffer
	     (url-retrieve-synchronously
	      "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	      'silent 'inhibit-cookies)
	   (goto-char (point-max))
	   (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))

     (straight-use-package 'use-package)
     (setq straight-vc-git-default-clone-deptfh 1)

     ;; package.el
     ;; so package-list-package will include them.
     (require 'package)
     (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
     (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
   #+end_src

   All custom variables that automatically generated by emacs put them
   in custom-variables.el file
   #+NAME: custom-variables.el
   #+BEGIN_SRC emacs-lisp
     (setq custom-file
	   (concat (file-name-directory user-init-file) "custom-variables.el"))
     (when (file-exists-p custom-file)
       (load custom-file))
     (put 'dired-find-alternate-file 'disabled nil)
   #+END_SRC

** Preferences
*** Display

    #+NAME: disable few elements in UI
    #+BEGIN_SRC emacs-lisp
      (setq ring-bell-function 'ignore	; Silence please, no more beeps.
	    echo-keystrokes 0.5)		; Echo keystrokes faster.

      (menu-bar-mode -1)			; Menu bar is gone.
      (tool-bar-mode -1)			; Tool bar is gone.
      (scroll-bar-mode -1)			; Hide scrollbar.
      (blink-cursor-mode 0)			; I don't like blinking cursor.
      (global-hl-line-mode t)			; Highlight the current line, and make this global in all buffers.
      (global-set-key (kbd "<f5>") 'revert-buffer) ; Press F5 to refresh buffer.
      (desktop-save-mode t)			; Next time you open your emacs it will remember your last opened file.
      (save-place-mode t)			; It will remember last position you were in the file when you reopen it.
      (show-paren-mode t)			; Show you openning/closing parenthes.
      (winner-mode t)				; Always you can reopen last window you closed by fault.
      (global-auto-revert-mode t)		; Reload changes from the desk.
      (column-number-mode t)			; Show column numbers.

      (setq mode-require-final-newline t)	; Add newline at the end of file.
      (set-frame-parameter nil 'internal-border-width 0) ; Hide these annoying space margin on both sides.
      (set-frame-parameter nil 'top 0)		   ; Remove space from top in Full Screen
      (set-frame-parameter nil 'bottom 0)		   ; Remove space from bottom
    #+END_SRC

    #+NAME: tweaking scrolling to be smoother
    #+BEGIN_SRC emacs-lisp
      (setq mouse-wheel-scroll-amount '(1)	; Scroll gentley
	    mouse-wheel-progressive-speed nil ; Take it easy and don't accelerate.
	    scroll-conservatively 101		; Don't jump to the middle of screen.
	    hscroll-margin 1			; Don't scroll that early.
	    hscroll-step 1			; But scroll just a bit.
	    scroll-preserve-screen-position t) ; Keep the cursor in its position
    #+END_SRC

    #+NAME: fringe-mode
    #+BEGIN_SRC emacs-lisp
      (global-visual-line-mode 1)
      (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
      (fringe-mode 8)
    #+END_SRC


    #+NAME: spacemacs theme switcher (dark <-> light)
    #+BEGIN_SRC emacs-lisp
      (use-package spacemacs-theme
	:defer t
	:custom
	(spacemacs-theme-comment-bg nil))
      ;; If I ever want to use original comment color with italics together,
      ;; I should uncomment these 2 lines.
      ;; See https://github.com/nashamri/spacemacs-theme/issues/104
      ;; (custom-set-variables '(spacemacs-theme-custom-colors
      ;;                         '((comment-light . "#2aa1ae"))))
    #+END_SRC

    
    #+NAME: package to switch between dark/light theme.
    #+BEGIN_SRC emacs-lisp
      (use-package heaven-and-hell
	:init
	(setq heaven-and-hell-theme-type 'light)
	(setq heaven-and-hell-themes
	      '((light . spacemacs-light)
		(dark . spacemacs-dark)))
	:hook (after-init . heaven-and-hell-init-hook))
    #+END_SRC

    #+NAME: SF-Mono Nerd Font
    #+BEGIN_SRC emacs-lisp
      (setq ak/font-name "Liga Nerd Font Mono")
      (defcustom ak/font-size 15 "My default font size")

      (defun set-frame-font-size (&optional font-size)
	"Change fram font size to FONT-SIZE.
	  If no FONT-SIZE provided, reset the font size to its default variable."
	(let ((font-size
	       (or font-size
		   (eval (car (get 'ak/font-size 'standard-value))))))
	  (customize-set-variable 'ak/font-size font-size)
	  (set-frame-font
	   (format "%s %d" ak/font-name font-size) nil t)))

      (defun increase-frame-font ()
	"Increase frame font by one."
	(interactive)
	(set-frame-font-size (+ ak/font-size 1)))

      (defun decrease-frame-font ()
	"Decrease frame font by one."
	(interactive)
	(set-frame-font-size (- ak/font-size 1)))

      (defun reset-frame-font ()
	"Reset frame font to its default value."
	(interactive)
	(set-frame-font-size))
      (add-hook 'after-init-hook 'reset-frame-font)
    #+END_SRC

    #+NAME: enable-ligatures
    #+BEGIN_SRC emacs-lisp
      (when (window-system)
	(set-frame-font ak/font-name))
      (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
		     (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
		     (36 . ".\\(?:>\\)")
		     (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
		     (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
		     (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
		     (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
		     (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
		     (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
		     (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
		     (48 . ".\\(?:x[a-zA-Z]\\)")
		     (58 . ".\\(?:::\\|[:=]\\)")
		     (59 . ".\\(?:;;\\|;\\)")
		     (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
		     (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
		     (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
		     (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
		     (91 . ".\\(?:]\\)")
		     (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
		     (94 . ".\\(?:=\\)")
		     (119 . ".\\(?:ww\\)")
		     (123 . ".\\(?:-\\)")
		     (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
		     (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
		     )
		   ))
	(dolist (char-regexp alist)
	  (set-char-table-range composition-function-table (car char-regexp)
				`([,(cdr char-regexp) 0 font-shape-gstring]))))
    #+END_SRC

    #+NAME: no-bold-font
    #+BEGIN_SRC emacs-lisp
      (mapc
       (lambda (face)
	      (when (eq (face-attribute face :weight) 'bold)
		(set-face-attribute face nil :weight 'normal)))
       (face-list))
    #+END_SRC

    #+NAME: all-the-icons
    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons
	;; all-the-icons doesn't work without font-lock+
	;; and font-lock+ doesn't have autoloads so:
	:config
	(use-package font-lock+
	  :straight (:host github :repo "emacsmirror/font-lock-plus")
	  :config (require 'font-lock+)))
    #+END_SRC

    #+NAME: dired-mode-icons
    #+BEGIN_SRC emacs-lisp
      (setq dired-dwim-target t)
      (add-hook 'dired-mode-hook 'dired-hide-details-mode) ; Hide details by default
      (with-eval-after-load 'dired
	(define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file))

      (use-package all-the-icons-dired
	:after all-the-icons
	:hook (dired-mode . all-the-icons-dired-mode))
    #+END_SRC

    #+NAME: doom-mode
    #+BEGIN_SRC emacs-lisp
      (use-package doom-modeline
	:defer t
	:hook (after-init . doom-modeline-init))
    #+END_SRC

    #+NAME: ibuffer
    #+BEGIN_SRC emacs-lisp
      (defalias 'list-buffers 'ibuffer)
    #+END_SRC

*** Other

    Symlinks ask to follow disable that

    #+NAME: symlink
    #+BEGIN_SRC emacs-lisp
      (setq vc-follow-symlink t)
    #+END_SRC
    
    Instead of asking `yes` or `no`, it will prompt you for `y` or `n`

    #+NAME: yes-or-no
    #+BEGIN_SRC emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

    #+NAME: kill-processes
    #+BEGIN_SRC emacs-lisp
      (setq confirm-kill-processes nil)
    #+END_SRC

    The way emacs makes backups is in the same folder as the backed up
    file so we can change that and add a directory in which it saves
    it in.

    #+NAME: backups
    #+BEGIN_SRC emacs-lisp
      (setq backup-directory-alist '(("." . "~/.saves"))
      backup-by-copying t
	    delete-old-versions t
      kept-new-versions 10
      kept-old-versions 10
	    version-control t)

      (setq create-lockfiles nil)
    #+END_SRC
    
    There is a setting which makes C-k kill the entire line AND newline.

    #+NAME: kill-whole-line
    #+BEGIN_SRC emacs-lisp
      (setq kill-whole-line t)
    #+END_SRC

    #+NAME: Security
    #+BEGIN_SRC emacs-lisp
      (setq gnutls-verify-error t
	    tls-checktrust t)
    #+END_SRC

    #+NAME: history
    #+BEGIN_SRC emacs-lisp
      (setq savehist-file "~/.emacs.d/savehist"
	    history-length t
	    history-delete-duplicates t
	    savehist-save-minibuffer-history 1
	    savehist-additional-variables
	    '(kill-ring
	      search-ring
	      regexp-search-ring)
	    recentf-max-saved-items 50)
      (savehist-mode 1)
      (recentf-mode 1)
    #+END_SRC

    #+NAME: general startup settings
    #+BEGIN_SRC emacs-lisp
      (setq inhibit-startup-message t)
      (setq initial-scratch-message "")

      (use-package no-littering)
      (require 'recentf)
      (add-to-list 'recentf-exclude no-littering-etc-directory)

      (setq user-full-name "AlaaEddin Koraiem"
	    user-mail-address "alaadahmed@gmail.com")

      (use-package diminish)
    #+END_SRC


    #+NAME code-style
    #+BEGIN_SRC emacs-lisp
      (setq mode-require-final-newline t)

      (use-package editorconfig
	:config
	(editorconfig-mode t))
    #+END_SRC

* Packages
** which-key

   `which-key` shows you the keybindings as you type part of them, it will suggest you some keys.
   #+NAME: which-key
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config (which-key-mode))
   #+END_SRC

** magit

   Magit is the best git plugin ever made for emacs.

   #+NAME: magit
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind ("C-x g" . magit-status))
   #+END_SRC

   Also it is nice to see signs of modifications in our current file

   #+NAME: diff-hl
   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :hook ((dired-mode . diff-hl-dired-mode)
	      (magit-post-refresh . diff-hl-magit-post-refresh))
       :custom (diff-hl-flydiff-delay 0.5)
       :config
       (global-diff-hl-mode t))
   #+END_SRC

** helm
   
   There 3 completions are helm, ido-mode and ivy. They show you
   possible options of a multitude of functions even built it ones

   #+NAME: helm
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package helm
       :init
       (setq helm-follow-mode-persistent t
	     helm-autoresize-max-height 40
	     helm-display-header-line nil)
       :config
       (require 'helm-config)
       (helm-autoresize-mode t)
       (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
       (helm-mode t))
   #+END_SRC

** exec-path-from-shell
   
   Let Emacs knows about our Path:

   #+NAME: exec-path-from-shell
   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell)
     (when (memq window-system '(mac ns x))
       (exec-path-from-shell-initialize))
   #+END_SRC

** diminish

   #+NAME: diminish
   #+BEGIN_SRC emacs-lisp
     (use-package diminish)
   #+END_SRC

** projectile

   Projectile is made manage projects. So you search and run projects
   easily, it search for git repo or projectile file in your folder to
   consider it as a project folder

   #+NAME: projectile
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :config
       (projectile-mode t))
   #+END_SRC

** ivy
   
   Ivy is very nice and smooth completion solution for minibuffer

   #+NAME: ivy
   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :diminish (ivy-mode)
       :bind ("C-x b" . ivy-switch-buffer)
       :config
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq ivy-display-style 'fancy))
   #+END_SRC

** swiper

   #+NAME: swiper
   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :bind (("C-s" . swiper)
	      ("C-r" . swiper)
	      ("C-c C-r" . ivy-resume)
	      ("M-x" . counsel-M-x)
	      ("C-x C-f" . counsel-find-file))
       :config
       (progn
	 (ivy-mode 1)
	 (setq ivy-use-virtual-buffers t)
	 (setq ivy-display-style 'fancy)
	 (setq enable-recursive-minibuffers t)
	 (define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)
	 ))
   #+END_SRC

** counsel

   #+NAME: counsel
   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :config
       (counsel-mode))
   #+END_SRC

** avy

   #+NAME: avy
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :bind ("M-s" . avy-goto-char))
   #+END_SRC

** company

   Auto completion for words in programming languages

   #+NAME: company
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :custom
       (company-require-match nil)
       (company-minimum-prefix-length 2)
       (company-idle-delay 1)
       (company-tooltip-align-annotation t)
       (company-frontends '(company-pseudo-tooltip-frontend
			    company-echo-metadata-frontend))
       :commands (company-mode global-company-mode company-complete
			       company-complete-common company-manual-begin
			       company-grap-line)
       :bind (:map company-active-map
		   ("C-n" . company-select-next)
		   ("C-p" . company-select-previous))
       :hook ((prog-mode . company-mode)
	      (comint-mode . company-mode)))
   #+END_SRC

** elm-mode
   
   #+NAME: elm-mode
   #+BEGIN_SRC emacs-lisp
     (use-package elm-mode)
   #+END_SRC

** lsp-mode

   #+NAME: lsp-mode
   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :commands lsp
       :diminish lsp-mode
       :hook
       ((python-mode . lsp)
	(elm-mode . lsp)
	(c-mode . lsp))
       :init
       (add-to-list 'exec-path "/Users/alaadahmed/elixir-ls/release")
       :config
       (setq lsp-prefer-flymake nil
	     lsp-enable-snippet t
	     lsp-auto-execute-action t
	     lsp-eldoc-render-all t
	     lsp-enable-completion-at-point t
	     lsp-enable-xref t
	     lsp-enable-indentation t))

     (add-hook
      'elixir-mode-hook
      (lambda ()
	(lsp)
	(add-hook 'before-save-hook 'lsp-format-buffer nil t)))

     ;; lsp-ui is a nicer ui while your editing with inline errors and
     ;; stuff
     (use-package lsp-ui
       :after lsp-mode
       :hook (lsp-mode-hook . lsp-ui-mode))

     ;; Company support for autocompletion. The setq is optional but the
     ;; push is required for company to find the completions
     (use-package company-lsp
       :after '(company lsp-mode)
       (setq company-lsp-cache-candidates t
	     company-lsp-async t)
       (push 'company-lsp company-backends))

     ;; Makes nice icons for functions
     (use-package company-box
       :hook (company-mode . company-box-mode))
   #+END_SRC

** elixir-mode

   #+NAME: elixir-mode
   #+BEGIN_SRC emacs-lisp
     (use-package elixir-mode)

     (defvar lsp-elixir--config-options (make-hash-table))
     (add-hook 'lsp-after-initialize-hook
	       (lambda ()
		 (lsp--set-configuration `(:elixirLS, lsp-elixir--config-options))))
   #+END_SRC

** smartparens
   Who can live without smart parenthes, openning/closing parenthes

   #+NAME: smartparens
   #+BEGIN_SRC emacs-lisp
      (use-package smartparens
	:config
	(require 'smartparens-config)
	(smartparens-global-mode))
   #+END_SRC

** ace-window

   Let's make moving between windows a breeze
   
   #+NAME: ace-window
   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :init
       (progn
	 (global-set-key [remap other-window] 'ace-window)
	 (custom-set-faces
	  '(aw-leading-char-face
	    ((t (:inherit ace-jump-face-forground :height 2.0)))))
	 ))
   #+END_SRC

** command-log

   Nice to see keybinding that you type immediately

   #+NAME: command-log-mode
   #+BEGIN_SRC emacs-lisp
     (use-package command-log-mode
       :commands (command-log-mode global-command-log-mode))
   #+END_SRC

** treemacs
   
   There is treemacs and neotree. Treemacs has support for a lot of plugins including magit and projectile.
   #+NAME: treemacs
   #+BEGIN_SRC emacs-lisp

   #+END_SRC

** evil-mode

   Let's make our Emacs even more EVIL

   #+NAME: evil
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; C-i is used in Vim as counterpart to C-o for going back and forth
     ;; in the jump list. It also happens to be interpreted as TAB, simply
     ;; because terminals are a nightmare. Fortunately GUI Emacs can be
     ;; told to not resolve C-i to indentation by defining a function in
     ;; key-translation-map that returns the desired key. That way I’m
     ;; sending a custom <C-i> when Evil is active, in normal state and C-i
     ;; (as opposed to the TAB key) has been pressed, otherwise TAB is
     ;; passed through.

     (defun my-translate-C-i (_prompt)
       (if (and (= (length (this-single-command-raw-keys)) 1)
		(eql (aref (this-single-command-raw-keys) 0) ?\C-i)
		(bound-and-true-p evil-mode)
		(eq evil-state 'normal))
	   (kbd "<C-i>")
	 (kbd "TAB")))

     (define-key key-translation-map (kbd "TAB") 'my-translate-C-i)

     (use-package evil
       :init
       (setq evil-vsplit-window-right t)
       (setq evil-split-window-below t)
       (setq evil-want-Y-yank-to-eol t)
       :hook (after-init . evil-mode)
       :config
       (define-key evil-insert-state-map "\C-p" nil)
       (define-key evil-insert-state-map "\C-n" nil)
       (with-eval-after-load 'evil-vars
	 (setq evil-want-C-w-in-emacs-state t))
       (with-eval-after-load 'evil-maps
	 (define-key evil-motion-state-map (kbd "SPC") nil) ; Unbind "SPC" from Evil, it goes to Emacs now.
	 (define-key evil-motion-state-map (kbd "RET") nil) ; Unbind "RET" from Evil, it goes to Emacs now.
	 (define-key evil-motion-state-map (kbd "TAB") nil) ; Unbind "TAB" from Evil, it goes to Emacs now.
	 (define-key evil-normal-state-map (kbd "C-.") nil)
	 (define-key evil-normal-state-map (kbd "M-.") nil)
	 (define-key evil-motion-state-map (kbd "<C-i>") 'evil-jump-forward)
	 (define-key evil-insert-state-map (kbd "C-w") 'evil-window-map)))

     (use-package evil-surround
       :after evil
       :hook (evil-mode . global-evil-surround-mode))

     (use-package evil-numbers
       :after evil
       :bind (
	      :map evil-normal-state-map
		   ("+" . evil-numbers/inc-at-pt)
		   ("-" . evil-numbers/dec-at-pt)))

     (use-package evil-commentary
       :after evil
       :hook (evil-mode . evil-commentary-mode))
   #+END_SRC

** htmlize
   
   This enable you to export org file as html and can open in browser

   #+NAME: htmlize
   #+BEGIN_SRC emacs-lisp
     (use-package htmlize)
   #+END_SRC

* Keybindings

  #+NAME: keybindings
  #+BEGIN_SRC emacs-lisp
    (use-package general
      :config
      (general-define-key
       "C-x C-0" 'reset-frame-font
       "C-x C--" 'decrease-frame-font
       "C-x C-=" 'increase-frame-font
       "C-x C-+" 'text-scale-adjust
       "C-c <f6>" 'heaven-and-hell-load-default-theme
       "<f6>" 'heaven-and-hell-toggle-theme))
  #+END_SRC

